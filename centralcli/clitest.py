#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import importlib
import sys
from pathlib import Path
from typing import List

import typer

# Detect if called from pypi installed package or via cloned github repo (development)
try:
    from centralcli import cli, log, utils
except (ImportError, ModuleNotFoundError) as e:
    pkg_dir = Path(__file__).absolute().parent
    if pkg_dir.name == "centralcli":
        sys.path.insert(0, str(pkg_dir.parent))
        from centralcli import cli, log, utils
    else:
        print(pkg_dir.parts)
        raise e

from centralcli.central import CentralApi, Response  # noqa

app = typer.Typer()

tty = utils.tty


# TODO add cache for webhooks
@app.command(short_help="Test WebHook")
def webhook(
    wid: str = typer.Argument(..., help="WebHook ID",),
    default: bool = typer.Option(False, "-d", is_flag=True, help="Use default central account", show_default=False,),
    debug: bool = typer.Option(False, "--debug", envvar="ARUBACLI_DEBUG", help="Enable Additional Debug Logging",),
    account: str = typer.Option("central_info",
                                envvar="ARUBACLI_ACCOUNT",
                                help="The Aruba Central Account to use (must be defined in the config)",),
):
    resp = cli.central.request(cli.central.test_webhook, wid)

    cli.display_results(resp, tablefmt="rich", title="WebHook Test Results")

@app.command(hidden=False, short_help="Test Central API methods directly", epilog="Output is displayed in yaml by default.")
def method(
    method: str = typer.Argument(..., autocompletion=cli.cache.method_test_completion, show_default=False,),
    kwargs: List[str] = typer.Argument(None, metavar="args/kwargs", help="Provide args/kwargs in format: [cyan]arg1 arg2 keyword=value keyword2=value2[/]", show_default=False,),
    _help: bool = typer.Option(False, "--doc", help="Get details on required args/keyword args for provided method."),
    do_json: bool = cli.options.do_json,
    do_yaml: bool = cli.options.do_yaml,
    do_csv: bool = cli.options.do_csv,
    do_table: bool = cli.options.do_table,
    raw: bool = cli.options.raw,
    outfile: Path = cli.options.outfile,
    pager: bool = cli.options.pager,
    debug: bool = cli.options.debug,
    default: bool = cli.options.default,
    account: str = cli.options.account,
    debugv: bool = typer.Option(
        False, "--debugv",
        envvar="ARUBACLI_VERBOSE_DEBUG",
        help="Enable verbose Debug Logging",
        hidden=True,
        callback=cli.verbose_debug_callback,
    ),
    update_cache: bool = cli.options.update_cache,
) -> None:
    """Dev testing commands to run CentralApi methods from command line.

    :warning:  This is a development aid.  Every API endpoint in Aruba Central
    has a corresponding method/function in Central CLI.  The functions are
    generated by a script that parses the OpenAPI specs, and are generally
    best-effort/not tested.  Once required by a command in Central CLI they
    are coppied, tweaked if necessary and renamed (those are tested).

    The auto generated functions follow a consistent naming format.
    {swagger drop down text}_{other stuff from spec}_{method ie get}_{more stuff from spec}
    i.e.: monitoring_external_controller_get_wireless_clients_v1
    [italic]methods get, post, patch, delete are also available[/]

    [dark_olive_green2]Tab completion returns available methods.[/]

    Args:
        method (str): CentralAPI method to test.
        kwargs (List[str], optional): list of args kwargs to pass to function.

    format: arg1 arg2 keyword=value keyword2=value2
        or  arg1, arg2, keyword = value, keyword2 = value2

    Examples: [cyan]cencli test method monitoring_external_controller_get_switch_poe_details_for_all_ports_v1 SN24ABC123[/]

        [dark_olive_green2]Use --doc flag to see docstr for for the python method, which
        provides details on the required args / kwargs.[/]
        [cyan]cencli test method METHOD_NAME --doc[/]

    Command will output all attributes of the Response object, which includes the
    raw response from the Aruba Central API gateway.

    :information:  [italic][cyan]--account[/cyan]flag must be used to test alternative accounts.
       It does not honor re-use of last-account even if [cyan]forget_account_after[/cyan] is set in config[/italic]
    """
    # Find function (method)
    cli.cache(refresh=update_cache)
    central = CentralApi(account)
    bpdir = Path(__file__).parent / "boilerplate"
    all_calls = [
        importlib.import_module(f"centralcli.{bpdir.name}.{f.stem}") for f in bpdir.iterdir()
        if not f.name.startswith("_") and f.suffix == ".py"
    ]
    for m in all_calls:
        log.debug(f"Looking for {method} in {m.__file__.split('/')[-1]}")
        if hasattr(m.AllCalls(), method):
            central = m.AllCalls(account)
            break

    if not hasattr(central, method):
        cli.exit(f"[cyan]{method}[/] [bright_red]does not exist[/]")

    if _help:
        doc_str: str = getattr(central, method).__doc__
        if doc_str:
            old_ret = "Response: CentralAPI Response object"
            new_ret = "Response from Aruba Central API gateway."
            doc_str_list = doc_str.splitlines(keepends=True)
            doc_str = f'[bright_green]{doc_str_list[0]}[/]'
            if len(doc_str_list) > 1:
                doc_str = f'{doc_str}{"".join(doc_str_list[1:])}'
            cli.exit(doc_str.replace(old_ret, new_ret), code=0, emoji=False)
        else:
            cli.exit(f"Sorry, {getattr(central, method).__name__}, lacks a docstr.  No help.", code=0)

    # pasrse args/kwargs from command line
    kwargs = kwargs or {}
    kwargs = (
        "~".join(kwargs).replace("'", "").replace('"', '').replace("~=", "=").replace("=~", "=").replace(",~", "~").split("~")
    )
    args = [k if not k.isdigit() else int(k) for k in kwargs if k and "=" not in k]
    kwargs = [k.split("=") for k in kwargs if "=" in k]
    kwargs = {k[0]: k[1] if not k[1].isdigit() else int(k[1]) for k in kwargs}
    for arg in args:
        if isinstance(arg, str):
            if arg.startswith("[") and arg.endswith("]"):
                args[args.index(arg)] = [a if not a.isdigit() else int(a) for a in arg.strip("[]").split(",")]
    for k, v in kwargs.items():
        if isinstance(v, str):
            if v.startswith("[") and v.endswith("]"):
                kwargs[k] = [vv if not vv.isdigit() else int(vv) for vv in v.strip("[]").split(",")]
            if v.lower() in ["true", "false"]:
                kwargs[k] = True if v.lower() == "true" else False

    from rich.console import Console
    c = Console(file=outfile)

    def _check_bool_to_str(args, kwargs, *, response: Response = None, resp_str: str = None) -> Response:
        resp_str = resp_str or response.output
        if isinstance(resp_str, str) and ("True" in resp_str or "False" in resp_str) and "value should be str" in resp_str:
            log.warning(f"{resp_str} Lame! Converting to str!", show=True, caption=True)
            args = tuple([str(a).lower() if isinstance(a, bool) else a for a in args])
            kwargs = {k: str(v).lower() if isinstance(v, bool) else v for k, v in kwargs.items()}
            response = central.request(getattr(central, method), *args, **kwargs)
        return response if response is not None else Response(error=resp_str)

    try:
        resp = central.request(getattr(central, method), *args, **kwargs)
        resp = _check_bool_to_str(args, kwargs, response=resp)
    except TypeError as e:
        resp = _check_bool_to_str(args, kwargs, resp_str=str(e))

    attrs = {
        k: v for k, v in resp.__dict__.items() if k not in ["output", "raw", "data_key"] and (log.DEBUG or not k.startswith("_"))
    }

    req = (
        f"central.{method}({', '.join(str(a) for a in args)}{', ' if args else ''}"
        f"{', '.join([f'{k}={kwargs[k]}' for k in kwargs]) if kwargs else ''})"
    )

    c.print(req)
    c.print("\n".join([f"  {k}: {v}" for k, v in attrs.items()]))

    tablefmt = cli.get_format(
        do_json, do_yaml, do_csv, do_table, default="yaml"
    )

    if resp.raw and resp.output != resp.raw:
        typer.echo(f"\n{typer.style('CentralCLI Response Output', fg='bright_green')}:")
        cli.display_results(data=resp.output, tablefmt=tablefmt, pager=pager, outfile=outfile)
    if resp.raw:
        typer.echo(f"\n{typer.style('Raw Response Output', fg='bright_green')}:")
        cli.display_results(data=resp.raw, tablefmt="json", pager=pager, outfile=outfile)


@app.command(hidden=True,)
def command(
    import_file: Path = cli.arguments.import_file,
    yes: bool = cli.options.yes,
    do_json: bool = cli.options.do_json,
    do_yaml: bool = cli.options.do_yaml,
    do_csv: bool = cli.options.do_csv,
    do_table: bool = cli.options.do_table,
    raw: bool = cli.options.raw,
    outfile: Path = cli.options.outfile,
    pager: bool = cli.options.pager,
    debug: bool = cli.options.debug,
    default: bool = cli.options.default,
    account: str = cli.options.account,
    debugv: bool = typer.Option(
        False, "--debugv",
        envvar="ARUBACLI_VERBOSE_DEBUG",
        help="Enable verbose Debug Logging",
        hidden=True,
        callback=cli.verbose_debug_callback,
    ),
    update_cache = cli.options.update_cache,
) -> None:
    """This is a hidden test command used for automated testing.

    This command should not be used.

    What this command does changes based on what needs to be tested at the time.
    """
    ...


@app.callback()
def callback():
    """
    Test Webhook or run a centralcli function directly (all Aruba Central API endpoints are available)
    """
    pass


if __name__ == "__main__":
    app()
