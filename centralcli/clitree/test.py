#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import importlib
from pathlib import Path
from typing import List

import typer

from centralcli import api_clients, common, config, log, render
from centralcli.client import Session
from centralcli.response import Response

app = typer.Typer()
api = api_clients.classic


# CACHE add cache for webhooks
@app.command()
def webhook(
    wid: str = common.arguments.wid,
    default: bool = common.options.default,
    debug: bool = common.options.debug,
    workspace: str = common.options.workspace,
):
    """Test WebHook Notifications."""
    resp = api.session.request(api.central.test_webhook, wid)

    render.display_results(resp, tablefmt="rich", title="WebHook Test Results")


@app.command(hidden=False, short_help="Test Central API methods directly", epilog="Output is displayed in yaml by default.")
def method(
    method: str = typer.Argument(..., autocompletion=common.cache.method_test_completion, show_default=False,),
    kwargs: List[str] = typer.Argument(None, metavar="args/kwargs", help="Provide args/kwargs in format: [cyan]arg1 arg2 keyword=value keyword2=value2[/]", show_default=False,),
    _help: bool = typer.Option(False, "--doc", help="Get details on required args/keyword args for provided method."),
    do_json: bool = common.options.do_json,
    do_yaml: bool = common.options.do_yaml,
    do_csv: bool = common.options.do_csv,
    do_table: bool = common.options.do_table,
    raw: bool = common.options.raw,
    outfile: Path = common.options.outfile,
    pager: bool = common.options.pager,
    debug: bool = common.options.debug,
    debugv: bool = common.options.debugv,
    default: bool = common.options.default,
    workspace: str = common.options.workspace,
    update_cache: bool = common.options.update_cache,
) -> None:  # pragma: no cover
    """Dev testing commands to run CentralApi methods from command line.

    :warning:  This is a development aid.  Every API endpoint in Aruba Central
    has a corresponding method/function in Central CLI.  The functions are
    generated by a script that parses the OpenAPI specs, and are generally
    best-effort/not tested.  Once required by a command in Central CLI they
    are coppied, tweaked if necessary and renamed (those are tested).

    The auto generated functions follow a consistent naming format.
    {swagger drop down text}_{other stuff from spec}_{method ie get}_{more stuff from spec}
    i.e.: monitoring_external_controller_get_wireless_clients_v1
    [italic]methods get, post, patch, delete are also available[/]

    [dark_olive_green2]Tab completion returns available methods.[/]

    Args:
        method (str): CentralAPI method to test.
        kwargs (List[str], optional): list of args kwargs to pass to function.

    format: arg1 arg2 keyword=value keyword2=value2
        or  arg1, arg2, keyword = value, keyword2 = value2

    Examples: [cyan]cencli test method monitoring_external_controller_get_switch_poe_details_for_all_ports_v1 SN24ABC123[/]

        [dark_olive_green2]Use --doc flag to see docstr for for the python method, which
        provides details on the required args / kwargs.[/]
        [cyan]cencli test method METHOD_NAME --doc[/]

    Command will output all attributes of the Response object, which includes the
    raw response from the Aruba Central API gateway.

    :information:  [italic][cyan]--ws[/]|[cyan]--workspace[/cyan] flag must be used to test alternative workspaces.
       It does not honor re-use of last-account even if [cyan]forget_workspace_after[/cyan] is set in config[/italic]
    """
    if update_cache:
        common.cache(refresh=update_cache)
    # Do Not honor sticky workspace for test method
    if config.sticky_workspace_file.is_file():
        config.sticky_workspace_file.unlink()

    # Find function (method)
    bpdir = Path(__file__).parent.parent / "boilerplate"
    all_calls = [
        importlib.import_module(f"centralcli.{bpdir.name}.{f.stem}") for f in bpdir.iterdir()
        if not f.name.startswith("_") and f.suffix == ".py"
    ]
    client = Session(config.classic.base_url)
    for m in all_calls:
        log.debug(f"Looking for {method} in {m.__file__.split('/')[-1]}")
        if hasattr(m.AllCalls(client), method):
            api.all_calls = m.AllCalls(client)
            break

    classic_props = [item for item in dir(api) if not item.startswith("_")]
    func = None
    for prop in classic_props:
        if hasattr(getattr(api, prop), method):
            full_api = getattr(api, prop)
            func = getattr(full_api, method)

    if not func:
        common.exit(f"[cyan]{method}[/] [bright_red]does not exist[/]")

    if _help:
        doc_str: str = func.__doc__
        if doc_str:
            old_ret = "Response: CentralAPI Response object"
            new_ret = "Response from Aruba Central API gateway."
            doc_str_list = doc_str.splitlines(keepends=True)
            doc_str = f'[bright_green]{doc_str_list[0]}[/]'
            if len(doc_str_list) > 1:
                doc_str = f'{doc_str}{"".join(doc_str_list[1:])}'
            common.exit(doc_str.replace(old_ret, new_ret), code=0, emoji=False)
        else:
            common.exit(f"Sorry, {func.__name__}, lacks a docstr.  No help.", code=0)

    # pasrse args/kwargs from command line
    kwargs = kwargs or {}
    kwargs = (
        "~".join(kwargs).replace("'", "").replace('"', '').replace("~=", "=").replace("=~", "=").replace(",~", "~").split("~")
    )
    args = [k if not k.isdigit() else int(k) for k in kwargs if k and "=" not in k]
    kwargs = [k.split("=") for k in kwargs if "=" in k]
    kwargs = {k[0]: k[1] if not k[1].isdigit() else int(k[1]) for k in kwargs}
    for arg in args:
        if isinstance(arg, str):
            if arg.startswith("[") and arg.endswith("]"):
                args[args.index(arg)] = [a if not a.isdigit() else int(a) for a in arg.strip("[]").split(",")]
    for k, v in kwargs.items():
        if isinstance(v, str):
            if v.startswith("[") and v.endswith("]"):
                kwargs[k] = [vv if not vv.isdigit() else int(vv) for vv in v.strip("[]").split(",")]
            if v.lower() in ["true", "false"]:
                kwargs[k] = True if v.lower() == "true" else False

    from rich.console import Console
    c = Console(file=outfile)

    def _check_bool_to_str(args, kwargs, *, response: Response = None, resp_str: str = None) -> Response:
        resp_str = resp_str or response.output
        if isinstance(resp_str, str) and ("True" in resp_str or "False" in resp_str) and "value should be str" in resp_str:
            log.warning(f"{resp_str} Lame! Converting to str!", show=True, caption=True)
            args = tuple([str(a).lower() if isinstance(a, bool) else a for a in args])
            kwargs = {k: str(v).lower() if isinstance(v, bool) else v for k, v in kwargs.items()}
            response = api.session.request(func, *args, **kwargs)
        return response if response is not None else Response(error=resp_str)

    try:
        resp = api.session.request(func, *args, **kwargs)
        resp = _check_bool_to_str(args, kwargs, response=resp)
    except TypeError as e:
        resp = _check_bool_to_str(args, kwargs, resp_str=str(e))

    attrs = {
        k: v for k, v in resp.__dict__.items() if k not in ["output", "raw", "data_key", "caption"] and (log.DEBUG or not k.startswith("_"))
    }

    req = (
        f"{full_api.__class__.__name__}.{method}({', '.join(str(a) for a in args)}{', ' if args else ''}"
        f"{', '.join([f'{k}={kwargs[k]}' for k in kwargs]) if kwargs else ''})"
    )

    c.print(req)
    c.print("\n".join([f"  {k}: {v}" for k, v in attrs.items()]))

    tablefmt = common.get_format(
        do_json, do_yaml, do_csv, do_table, default="yaml"
    )

    if resp.raw and resp.output != resp.raw:
        typer.echo(f"\n{typer.style('CentralCLI Response Output', fg='bright_green')}:")
        render.display_results(data=resp.output, tablefmt=tablefmt, pager=pager, outfile=outfile)
    if resp.raw:
        typer.echo(f"\n{typer.style('Raw Response Output', fg='bright_green')}:")
        render.display_results(data=resp.raw, tablefmt="json", pager=pager, outfile=outfile)


@app.command(hidden=True,)
def command(
    sort_by: str = common.options.sort_by,
    reverse: bool = common.options.reverse,
    yes: bool = common.options.yes,
    do_json: bool = common.options.do_json,
    do_yaml: bool = common.options.do_yaml,
    do_csv: bool = common.options.do_csv,
    do_table: bool = common.options.do_table,
    raw: bool = common.options.raw,
    outfile: Path = common.options.outfile,
    pager: bool = common.options.pager,
    debug: bool = common.options.debug,
    default: bool = common.options.default,
    workspace: str = common.options.workspace,
    debugv: bool = common.options.debugv,
    update_cache = common.options.update_cache,
) -> None:  # pragma: no cover
    """This is a hidden test command used for automated testing.

    This command should not be used.

    What this command does changes based on what needs to be tested at the time.
    """
    from ..cnx.api import CentralAPI
    # from centralcli.constants import APDeployment, DeviceStatusFilter
    api = CentralAPI()
    tablefmt = common.get_format(do_json=do_json, do_yaml=do_yaml, do_csv=do_csv, do_table=do_table)
    resp = api.session.request(api.monitoring.get_aps)  #  deployment=APDeployment.STANDALONE, status=DeviceStatusFilter.ONLINE, limit=3)
    render.display_results(resp, tablefmt=tablefmt, outfile=outfile, pager=pager, sort_by=sort_by, reverse=reverse, output_by_key="deviceName")
    ...


@app.callback()
def callback():
    """
    Test Webhook or run a centralcli function directly (all Aruba Central [dim italic](classic)[/] API endpoints are available)
    """
    pass


if __name__ == "__main__":
    app()
